// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
}

enum ReportType {
  CONTENT_ERROR
  SPELLING_ERROR
  INAPPROPRIATE_CONTENT
  COPYRIGHT_VIOLATION
  DUPLICATE_CONTENT
  MISSING_INFORMATION
  INCORRECT_INFORMATION
  OTHER
}

enum ReportStatus {
  PENDING
  UNDER_REVIEW
  RESOLVED
  REJECTED
  DISMISSED
}

model User {
  id                String              @id @default(uuid())
  name              String
  email             String              @unique
  password          String
  role              UserRole            @default(USER)
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  imageUrl          String?
  books             Book[]
  ownedCollections  Collection[]        @relation("OwnedCollections")
  sharedCollections CollectionShare[]
  sharedNotes       NoteShare[]
  preferences       UserPreference[]
  progress          Progress[]
  notes             Note[]
  bookRatings       BookRating[]
  paragraphRatings  ParagraphRating[]
  authorRatings     AuthorRating[]
  createdTags       Tag[]               // User-created tags
  reports           Report[]            // Reports created by this user
  resolvedReports   Report[]            @relation("ResolvedReports") // Reports resolved by this admin
}

model UserPreference {
  id        String   @id @default(uuid())
  userId    String
  key       String
  value     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, key])
}

model Collection {
  id          String            @id @default(uuid())
  name        String
  description String?
  ownerId     String?
  isPublic    Boolean           @default(false)
  deletedAt   DateTime?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  createdBy   String?
  updatedBy   String?
  owner       User?             @relation("OwnedCollections", fields: [ownerId], references: [id], onDelete: Cascade)
  books       Book[]
  sharedWith  CollectionShare[]

  @@index([ownerId])
  @@index([isPublic])
  @@index([deletedAt])
  @@index([name])
}

model CollectionShare {
  collectionId String
  userId       String
  createdAt    DateTime   @default(now())
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([collectionId, userId])
}

model Book {
  id                String       @id @default(uuid())
  workId            String?       // Identifier for grouping editions/languages of same work
  userId            String?
  collectionId      String?
  publisherId       String?
  title             String
  description       String?
  edition           String?
  editionPublished  Int?
  originalLanguage  String       @default("en")
  originalPublished Int?
  imageUrl          String?
  shoppingUrl       String?
  language          String       @default("en") // e.g. "en", "fr"
  slug              String?      @unique // SEO-friendly URL
  genre             String?      // Book categorization
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  isPublic          Boolean      @default(false)
  isDraft          Boolean      @default(true)
  deletedAt         DateTime?
  createdBy         String?
  updatedBy         String?
  orderInCollection Int?
  user              User?        @relation(fields: [userId], references: [id])
  collection        Collection?  @relation(fields: [collectionId], references: [id])
  publisher         Publisher?   @relation(fields: [publisherId], references: [id])
  paragraphs        Paragraph[]
  tags              BookTag[]
  ratings           BookRating[]
  authors           BookAuthor[]
  Note              Note[]
  reports           Report[]

  @@index([workId])
  @@index([userId])
  @@index([collectionId])
  @@index([publisherId])
  @@index([deletedAt])
  @@index([isPublic])
  @@index([isDraft])
  @@index([language])
  @@index([originalLanguage])
  @@index([createdAt])
  @@index([title])
  @@index([genre])
  @@index([editionPublished])
  @@index([originalPublished])
  // Composite indexes for common query patterns
  @@index([workId, language]) // All editions of a work in specific language
  @@index([userId, deletedAt]) // User's books
  @@index([isPublic, deletedAt]) // Public books
  @@index([userId, isDraft]) // User's drafts vs published books
  @@index([language, isPublic]) // Books by language
  @@index([publisherId, editionPublished]) // Books by publisher and year
}

model Tag {
  id          String         @id @default(uuid())
  name        String         @unique
  description String?
  isSystem    Boolean        @default(false) // true for system tags, false for user tags
  createdBy   String?        // userId for user-created tags, null for system tags
  isPublic    Boolean        @default(false) // Whether user tag can be used by others
  deletedAt   DateTime?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  creator     User?          @relation(fields: [createdBy], references: [id])
  books       BookTag[]
  paragraphs  ParagraphTag[]
  authors     AuthorTag[]
  notes       NoteTag[]

  @@index([name])
  @@index([deletedAt])
  @@index([isSystem])
  @@index([createdBy])
  @@index([isPublic])
  @@index([isSystem, isPublic]) // For filtering available tags
  @@index([createdBy, name]) // For user's tag management
}

model BookTag {
  bookId String
  tagId  String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([bookId, tagId])
  @@index([bookId])
  @@index([tagId])
}

model Paragraph {
  id              String          @id @default(uuid())
  bookId          String
  content         String
  order           Int
  chapterNumber   Int?            // Which chapter this paragraph belongs to
  readingTimeEst  Int?            // Estimated reading time in minutes
  deletedAt       DateTime?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  createdBy       String?
  updatedBy       String?
  book            Book            @relation(fields: [bookId], references: [id], onDelete: Cascade)
  notes           Note[]
  progress        Progress[]
  tags            ParagraphTag[]
  ratings         ParagraphRating[]
  reports         Report[]

  @@index([bookId])
  @@index([order])
  @@index([chapterNumber])
  @@index([deletedAt])
  @@index([bookId, order]) // Composite for paragraph ordering
  @@index([bookId, chapterNumber]) // Composite for chapter grouping
}


model Progress {
  id          String   @id @default(uuid())
  userId      String
  paragraphId String
  position    Int      // Character or word index in paragraph
  percentage  Float?   // Percentage read in this paragraph (0.0 to 1.0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user      User      @relation(fields: [userId], references: [id])
  paragraph Paragraph @relation(fields: [paragraphId], references: [id])

  @@unique([userId, paragraphId])
  @@index([userId])
  @@index([paragraphId])
  @@index([updatedAt])
  @@index([userId, updatedAt]) // Recent reading activity
  @@index([userId, percentage]) // Reading completion tracking
}

model Note {
  id            String    @id @default(uuid())
  userId        String
  bookId        String?
  paragraphId   String
  startIndex    Int?      // Start position of selected text (null for whole paragraph notes)
  endIndex      Int?      // End position of selected text (null for whole paragraph notes)
  selectedText  String?   // The actual selected text for quick reference (null for whole paragraph)
  text          String    // User's note content
  firstContent  String?   // Additional note content
  secondContent String?   // Additional note content  
  thirdContent  String?   // Additional note content
  noteType      String?   // Type of note: "highlight", "comment", "question", "paragraph_note", etc.
  isPublic      Boolean   @default(false)
  deletedAt     DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  createdBy     String?
  updatedBy     String?

  user       User        @relation(fields: [userId], references: [id])
  book       Book?       @relation(fields: [bookId], references: [id])
  paragraph  Paragraph?  @relation(fields: [paragraphId], references: [id])
  tags       NoteTag[]
  sharedWith NoteShare[]
  reports    Report[]    // Reports about this note

  @@index([userId])
  @@index([bookId])
  @@index([paragraphId])
  @@index([deletedAt])
  @@index([isPublic])
  @@index([createdAt])
  @@index([noteType])
  @@index([paragraphId, startIndex]) // For finding notes in specific text ranges
  @@index([paragraphId, noteType]) // For finding different types of notes per paragraph
}

model NoteTag {
  noteId String
  tagId  String
  note   Note   @relation(fields: [noteId], references: [id], onDelete: Cascade)
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([noteId, tagId])
  @@index([noteId]) // For finding all tags of a note
  @@index([tagId])  // For finding all notes with a tag
}

model Author {
  id        String         @id @default(uuid())
  name      String
  bio       String?
  deletedAt DateTime?
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  books     BookAuthor[]
  tags      AuthorTag[]
  links     AuthorLink[]
  ratings   AuthorRating[]
  reports   Report[]

  @@index([name])
  @@index([deletedAt])
}

model Publisher {
  id          String    @id @default(uuid())
  name        String
  description String?
  website     String?
  address     String?
  foundedYear Int?
  country     String?
  deletedAt   DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  books       Book[]
  reports     Report[]

  @@index([name])
  @@index([country])
  @@index([deletedAt])
}

model BookAuthor {
  bookId   String
  authorId String
  position Int?   // Order of authors if it matters (primary author = 1, etc.)
  book     Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)
  author   Author @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@id([bookId, authorId])
  @@index([bookId, position]) // For ordered author listing
}

model ParagraphTag {
  paragraphId String
  tagId       String
  paragraph   Paragraph @relation(fields: [paragraphId], references: [id], onDelete: Cascade)
  tag         Tag       @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([paragraphId, tagId])
  @@index([paragraphId])
  @@index([tagId])
}

model AuthorTag {
  authorId String
  tagId    String
  author   Author @relation(fields: [authorId], references: [id], onDelete: Cascade)
  tag      Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([authorId, tagId])
  @@index([authorId])
  @@index([tagId])
}

model AuthorLink {
  id       String  @id @default(uuid())
  authorId String
  url      String
  label    String?
  author   Author  @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([authorId])
}

model BookRating {
  id        String   @id @default(uuid())
  userId    String
  bookId    String
  rating    Int      // e.g. 1-5 (should be validated in application: 1 <= rating <= 5)
  comment   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  book Book @relation(fields: [bookId], references: [id], onDelete: Cascade)
  reports Report[] // Reports about this rating

  @@unique([userId, bookId])
  @@index([bookId])
  @@index([rating])
  @@index([createdAt])
  @@index([userId, rating]) // For user's rating history
}

model ParagraphRating {
  id          String   @id @default(uuid())
  userId      String
  paragraphId String
  rating      Int      // e.g. 1-5 (should be validated in application: 1 <= rating <= 5)
  comment     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  paragraph Paragraph @relation(fields: [paragraphId], references: [id], onDelete: Cascade)
  reports   Report[]  // Reports about this rating

  @@unique([userId, paragraphId])
  @@index([paragraphId])
  @@index([rating])
  @@index([createdAt])
  @@index([userId, rating]) // For user's rating history
}

model AuthorRating {
  id        String   @id @default(uuid())
  userId    String
  authorId  String
  rating    Int      // e.g. 1-5 (should be validated in application: 1 <= rating <= 5)
  comment   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  author Author @relation(fields: [authorId], references: [id], onDelete: Cascade)
  reports Report[] // Reports about this rating

  @@unique([userId, authorId])
  @@index([authorId])
  @@index([rating])
  @@index([createdAt])
  @@index([userId, rating]) // For user's rating history
}

model NoteShare {
  noteId    String
  userId    String
  createdAt DateTime @default(now())
  note      Note     @relation(fields: [noteId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([noteId, userId])
}

model Report {
  id          String       @id @default(uuid())
  userId      String       // User who submitted the report
  reportType  ReportType
  status      ReportStatus @default(PENDING)
  description String       // User's description of the issue
  adminNotes  String?      // Internal notes from admin/moderator (ADMIN-ONLY ACCESS)
  
  // Polymorphic relationship - only one of these should be set
  bookId            String?
  paragraphId       String?
  authorId          String?
  publisherId       String?
  noteId            String?         // Report about a specific note
  bookRatingId      String?         // Report about a book rating
  paragraphRatingId String?         // Report about a paragraph rating  
  authorRatingId    String?         // Report about an author rating
  
  // Resolution details (ADMIN-ONLY ACCESS)
  resolvedAt  DateTime?
  resolvedBy  String?      // Admin user ID who resolved it
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relationships
  user            User              @relation(fields: [userId], references: [id])
  book            Book?             @relation(fields: [bookId], references: [id])
  paragraph       Paragraph?        @relation(fields: [paragraphId], references: [id])
  author          Author?           @relation(fields: [authorId], references: [id])
  publisher       Publisher?        @relation(fields: [publisherId], references: [id])
  note            Note?             @relation(fields: [noteId], references: [id])
  bookRating      BookRating?       @relation(fields: [bookRatingId], references: [id])
  paragraphRating ParagraphRating?  @relation(fields: [paragraphRatingId], references: [id])
  authorRating    AuthorRating?     @relation(fields: [authorRatingId], references: [id])
  resolver        User?             @relation("ResolvedReports", fields: [resolvedBy], references: [id])

  @@index([userId])
  @@index([status])
  @@index([reportType])
  @@index([createdAt])
  @@index([bookId])
  @@index([paragraphId])
  @@index([authorId])
  @@index([publisherId])
  @@index([noteId])
  @@index([bookRatingId])
  @@index([paragraphRatingId])
  @@index([authorRatingId])
  @@index([resolvedBy])
  @@index([status, createdAt]) // For admin dashboard - pending reports first
  @@index([userId, status]) // User's report history
  @@index([reportType, status]) // For filtering by type and status
  
  // NOTE: Access to Report data should be restricted to ADMIN users only
  // Implement this restriction in your application layer/middleware
}
